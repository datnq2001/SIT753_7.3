pipeline {
    agent any
    
    // Global tools configuration
    tools {
        nodejs 'NodeJS-20'
    }
    
    // Environment variables and credentials
    environment {
        NODE_ENV = 'production'
        APP_NAME = 'dkin-butterfly-club'
        BUILD_VERSION = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        
        // Jenkins credentials (configure these in Jenkins Credentials)
        GITHUB_TOKEN = credentials('github-token')
        SNYK_TOKEN = credentials('snyk-token')
        
        // Application secrets
        JWT_SECRET = credentials('jwt-secret')
        SESSION_SECRET = credentials('session-secret')
        ENCRYPTION_KEY = credentials('encryption-key')
        
        // Deployment configuration
        STAGING_HOST = 'localhost'
        PRODUCTION_HOST = 'localhost'
        
        // Monitoring & Notifications
        NOTIFICATION_EMAIL = 'your-email@domain.com'
        
        // Quality gates
        COVERAGE_THRESHOLD = '80'
        SECURITY_THRESHOLD = 'medium'
    }
    
    // Build triggers
    triggers {
        pollSCM('H/5 * * * *')
        githubPush()
    }
    
    // Pipeline options
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
        retry(2)
        skipStagesAfterUnstable()
        ansiColor('xterm')
        timestamps()
    }
    
    stages {
        // ==================== STAGE 1: CHECKOUT ====================
        stage('üîÑ Checkout') {
            steps {
                echo 'üîÑ Checking out source code from GitHub...'
                checkout scm
                
                script {
                    // Set build metadata
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                    
                    env.GIT_BRANCH_NAME = sh(
                        script: "git rev-parse --abbrev-ref HEAD",
                        returnStdout: true
                    ).trim()
                    
                    env.BUILD_VERSION = "${env.BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}"
                    
                    echo "üìã Build Info:"
                    echo "   Version: ${env.BUILD_VERSION}"
                    echo "   Branch: ${env.GIT_BRANCH_NAME}"
                    echo "   Commit: ${env.GIT_COMMIT_SHORT}"
                }
            }
            post {
                success {
                    echo '‚úÖ Checkout completed successfully'
                }
                failure {
                    echo '‚ùå Checkout failed'
                }
            }
        }
        
        // ==================== STAGE 2: BUILD ====================
        stage('üöÄ Build') {
            steps {
                echo 'üöÄ Building application...'
                
                script {
                    // Create .env file from Jenkins credentials
                    writeFile file: '.env', text: """
NODE_ENV=${NODE_ENV}
PORT=3000

DB_PATH=./data/production.db
DB_TYPE=sqlite3

JWT_SECRET=${JWT_SECRET}
SESSION_SECRET=${SESSION_SECRET}
ENCRYPTION_KEY=${ENCRYPTION_KEY}

RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
SUBMIT_RATE_LIMIT_MAX=5

ALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com

SNYK_TOKEN=${SNYK_TOKEN}

APP_NAME=dKin Butterfly Club
APP_VERSION=${BUILD_VERSION}
APP_DESCRIPTION=Informative web page on Butterflies from around the world

LOG_LEVEL=info
LOG_FILE=./logs/app.log

ENABLE_ANALYTICS=true
ENABLE_EMAIL_NOTIFICATIONS=true
MAINTENANCE_MODE=false
"""
                }
                
                sh '''
                    echo "üì¶ Installing dependencies..."
                    npm ci
                    
                    echo "üîç Verifying environment configuration..."
                    node -e "console.log('Environment check:', require('./config/env').init().config.app.name)"
                    
                    echo "üìã Dependency audit..."
                    npm audit --audit-level moderate || true
                    
                    echo "üöÄ Build completed successfully"
                '''
            }
            post {
                success {
                    echo '‚úÖ Build stage completed successfully'
                }
                failure {
                    echo '‚ùå Build stage failed'
                }
            }
        }
        
        // ==================== STAGE 3: TEST ====================
        stage('üß™ Test') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        echo 'üß™ Running unit tests...'
                        sh '''
                            echo "Creating test environment..."
                            cp .env.example .env.test
                            
                            echo "Running validation tests..."
                            node demo_validation.js
                            
                            echo "Running custom validation tests..."
                            node test_validation.js > test-results.txt || true
                            
                            echo "Unit tests completed"
                        '''
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'test-results.txt', allowEmptyArchive: true
                        }
                    }
                }
                
                stage('Integration Tests') {
                    steps {
                        echo 'üîó Running integration tests...'
                        sh '''
                            echo "Starting server for integration tests..."
                            timeout 30 node index.js &
                            SERVER_PID=$!
                            
                            echo "Waiting for server to start..."
                            sleep 10
                            
                            echo "Running health checks..."
                            curl -f http://localhost:3000/ || echo "Health check failed"
                            
                            echo "Testing survey endpoint..."
                            curl -f http://localhost:3000/surveys || echo "Surveys endpoint test failed"
                            
                            echo "Stopping test server..."
                            kill $SERVER_PID || true
                            sleep 2
                        '''
                    }
                }
                
                stage('Performance Tests') {
                    steps {
                        echo 'üìà Running performance tests...'
                        sh '''
                            echo "Performance baseline check..."
                            # Basic performance metrics
                            echo "Memory usage check..."
                            node -e "console.log('Memory usage:', process.memoryUsage())"
                            
                            echo "Performance tests completed"
                        '''
                    }
                }
            }
            post {
                success {
                    echo '‚úÖ All tests passed successfully'
                }
                failure {
                    echo '‚ùå Some tests failed'
                }
            }
        }
        
        // ==================== STAGE 4: CODE QUALITY ====================
        stage('üìã Code Quality') {
            parallel {
                stage('ESLint Analysis') {
                    steps {
                        echo 'üîç Running ESLint code analysis...'
                        sh '''
                            # Install ESLint if not present
                            npm install eslint --save-dev || true
                            
                            # Run ESLint with checkstyle format
                            npx eslint . --ext .js --format checkstyle > eslint-report.xml || true
                            
                            # Count issues
                            ISSUES=$(grep -o "<error " eslint-report.xml | wc -l || echo "0")
                            echo "ESLint found $ISSUES issues"
                        '''
                    }
                    post {
                        always {
                            publishCheckStyleResults pattern: 'eslint-report.xml'
                            archiveArtifacts artifacts: 'eslint-report.xml', allowEmptyArchive: true
                        }
                    }
                }
                
                stage('Code Complexity') {
                    steps {
                        echo 'üìä Analyzing code complexity...'
                        sh '''
                            echo "Analyzing code complexity..."
                            
                            # Count lines of code
                            find . -name "*.js" -not -path "./node_modules/*" | xargs wc -l > complexity-report.txt
                            
                            # Check file sizes
                            find . -name "*.js" -not -path "./node_modules/*" -exec du -h {} \\; >> complexity-report.txt
                            
                            echo "Code complexity analysis completed"
                        '''
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'complexity-report.txt', allowEmptyArchive: true
                        }
                    }
                }
                
                stage('Documentation Check') {
                    steps {
                        echo 'üìù Checking documentation quality...'
                        sh '''
                            echo "Checking documentation files..."
                            
                            # Check for required documentation
                            for doc in README.md ENVIRONMENT_SETUP.md SECURITY_HARDENING.md; do
                                if [ -f "$doc" ]; then
                                    echo "‚úÖ $doc exists"
                                else
                                    echo "‚ùå $doc missing"
                                fi
                            done
                            
                            # Check documentation completeness
                            wc -l *.md > documentation-report.txt
                        '''
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'documentation-report.txt', allowEmptyArchive: true
                        }
                    }
                }
            }
            post {
                success {
                    echo '‚úÖ Code quality checks passed'
                }
                failure {
                    echo '‚ùå Code quality issues found'
                }
            }
        }
        
        // ==================== STAGE 5: SECURITY ====================
        stage('üîí Security') {
            parallel {
                stage('Vulnerability Scanning') {
                    steps {
                        echo 'üîç Running security vulnerability scan...'
                        sh '''
                            # Install and run Snyk security scanner
                            npm install -g snyk || true
                            
                            # Authenticate with Snyk
                            snyk auth ${SNYK_TOKEN} || echo "Snyk auth failed, using demo mode"
                            
                            # Test for vulnerabilities
                            snyk test --json > snyk-vulnerabilities.json || echo "Snyk scan completed with issues"
                            
                            # Monitor project
                            snyk monitor --project-name="${APP_NAME}" || true
                            
                            echo "Vulnerability scanning completed"
                        '''
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'snyk-*.json', allowEmptyArchive: true
                        }
                    }
                }
                
                stage('Secret Detection') {
                    steps {
                        echo 'üîç Scanning for hardcoded secrets...'
                        sh '''
                            echo "Scanning for potential secrets..."
                            
                            # Check for hardcoded secrets (excluding config files)
                            if grep -r "password\\|secret\\|key\\|token" --include="*.js" --exclude-dir=node_modules --exclude-dir=config . | grep -v "process.env" | grep -v "example"; then
                                echo "‚ö†Ô∏è Warning: Potential hardcoded secrets found" > secret-scan.txt
                            else
                                echo "‚úÖ No hardcoded secrets detected" > secret-scan.txt
                            fi
                            
                            # Check .env is not committed
                            if git ls-files | grep -q "^\.env$"; then
                                echo "‚ö†Ô∏è Warning: .env file found in git" >> secret-scan.txt
                            else
                                echo "‚úÖ .env file properly excluded" >> secret-scan.txt
                            fi
                            
                            cat secret-scan.txt
                        '''
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'secret-scan.txt', allowEmptyArchive: true
                        }
                    }
                }
                
                stage('Security Audit') {
                    steps {
                        echo 'üõ°Ô∏è Running security audit...'
                        sh '''
                            echo "Running security hardening checks..."
                            
                            # Make security audit script executable
                            chmod +x security_audit.sh
                            
                            # Run security audit
                            ./security_audit.sh > security-audit-report.txt || echo "Security audit completed with warnings"
                            
                            # Check file permissions
                            find . -name "*.js" -perm 777 > dangerous-permissions.txt || echo "No dangerous permissions found" > dangerous-permissions.txt
                            
                            echo "Security audit completed"
                        '''
                    }
                    post {
                        always {
                            archiveArtifacts artifacts: 'security-audit-report.txt,dangerous-permissions.txt', allowEmptyArchive: true
                        }
                    }
                }
            }
            post {
                success {
                    echo '‚úÖ Security scans completed successfully'
                }
                failure {
                    echo '‚ùå Security issues detected'
                }
            }
        }
        
        // ==================== STAGE 6: DEPLOY ====================
        stage('üöÄ Deploy') {
            parallel {
                stage('Deploy to Staging') {
                    when {
                        anyOf {
                            branch 'develop'
                            branch 'staging'
                            branch 'main'
                        }
                    }
                    
                    steps {
                        echo 'üöÄ Deploying to staging environment...'
                        
                        sh '''
                            echo "Preparing staging deployment..."
                            
                            # Create staging directory
                            mkdir -p staging-deploy
                            
                            # Copy application files
                            cp -r views staging-deploy/
                            cp -r schemas staging-deploy/
                            cp -r middleware staging-deploy/
                            cp -r config staging-deploy/
                            cp -r images staging-deploy/
                            cp index.js staging-deploy/
                            cp package*.json staging-deploy/
                            cp .env staging-deploy/
                            
                            echo "Deploying to staging server: ${STAGING_HOST}"
                            
                            # Deployment verification
                            if [ -f "staging-deploy/index.js" ]; then
                                echo "‚úÖ Staging deployment successful"
                            else
                                echo "‚ùå Staging deployment failed"
                                exit 1
                            fi
                        '''
                    }
                    post {
                        success {
                            echo '‚úÖ Staging deployment completed'
                        }
                        failure {
                            echo '‚ùå Staging deployment failed'
                        }
                    }
                }
                
                stage('Smoke Tests') {
                    steps {
                        echo 'üî• Running smoke tests...'
                        sh '''
                            echo "Running smoke tests on deployed application..."
                            
                            # Test environment validation
                            cd staging-deploy && node -e "
                                try {
                                    const { config } = require('./config/env').init();
                                    console.log('‚úÖ Environment validation passed');
                                    console.log('App:', config.app.name, 'v' + config.app.version);
                                } catch (error) {
                                    console.error('‚ùå Environment validation failed:', error.message);
                                    process.exit(1);
                                }
                            "
                            
                            echo "‚úÖ Smoke tests passed"
                        '''
                    }
                }
            }
            post {
                success {
                    echo '‚úÖ Deployment stage completed successfully'
                }
                failure {
                    echo '‚ùå Deployment stage failed'
                }
            }
        }
        
        // ==================== STAGE 7: RELEASE & MONITORING ====================
        stage('üéØ Release') {
            when {
                branch 'main'
            }
            
            input {
                message "Ready for production release?"
                ok "Release to Production"
                parameters {
                    choice(
                        name: 'DEPLOYMENT_STRATEGY',
                        choices: ['rolling', 'blue-green', 'canary'],
                        description: 'Choose deployment strategy'
                    )
                    booleanParam(
                        name: 'RUN_PERFORMANCE_TESTS',
                        defaultValue: true,
                        description: 'Run performance tests after deployment'
                    )
                }
            }
            
            steps {
                echo "üéØ Creating production release with ${params.DEPLOYMENT_STRATEGY} strategy..."
                
                sh '''
                    echo "Preparing production release..."
                    
                    # Create release directory
                    mkdir -p production-release
                    
                    # Copy staging deployment to production
                    cp -r staging-deploy/* production-release/
                    
                    # Create version file
                    echo "{
  \\"version\\": \\"${BUILD_VERSION}\\",
  \\"buildDate\\": \\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\",
  \\"commit\\": \\"${GIT_COMMIT_SHORT}\\",
  \\"branch\\": \\"${GIT_BRANCH_NAME}\\",
  \\"strategy\\": \\"${DEPLOYMENT_STRATEGY}\\"
}" > production-release/version.json
                    
                    # Create release package
                    tar -czf "${APP_NAME}-${BUILD_VERSION}.tar.gz" -C production-release .
                    
                    echo "Simulating production deployment..."
                    
                    if [ -f "production-release/version.json" ]; then
                        echo "‚úÖ Production release successful"
                        cat production-release/version.json
                    else
                        echo "‚ùå Production release failed"
                        exit 1
                    fi
                '''
            }
            post {
                success {
                    script {
                        // Archive release artifacts
                        archiveArtifacts artifacts: '*.tar.gz,production-release/**/*', fingerprint: true
                        
                        // Send success notification
                        emailext (
                            subject: "‚úÖ Production Release Successful - ${APP_NAME} v${BUILD_VERSION}",
                            body: """
                                <h3>Production Release Deployed Successfully</h3>
                                <p><strong>Application:</strong> ${APP_NAME}</p>
                                <p><strong>Version:</strong> ${BUILD_VERSION}</p>
                                <p><strong>Strategy:</strong> ${params.DEPLOYMENT_STRATEGY}</p>
                                <p><strong>Commit:</strong> ${GIT_COMMIT_SHORT}</p>
                                <p><strong>Build URL:</strong> ${BUILD_URL}</p>
                            """,
                            to: env.NOTIFICATION_EMAIL
                        )
                    }
                }
                failure {
                    emailext (
                        subject: "‚ùå Production Release Failed - ${APP_NAME}",
                        body: "Production release failed. Check build logs: ${BUILD_URL}",
                        to: env.NOTIFICATION_EMAIL
                    )
                }
            }
        }
        
        // ==================== STAGE 8: MONITORING ====================
        stage('üìä Monitoring') {
            parallel {
                stage('Performance Monitoring') {
                    steps {
                        echo 'üìà Setting up performance monitoring...'
                        sh '''
                            echo "Configuring performance monitoring..."
                            
                            # Create monitoring configuration
                            mkdir -p monitoring
                            
                            # Generate performance baseline
                            echo "{
  \\"application\\": \\"${APP_NAME}\\",
  \\"version\\": \\"${BUILD_VERSION}\\",
  \\"metrics\\": {
    \\"response_time_target\\": \\"< 200ms\\",
    \\"uptime_target\\": \\"> 99.5%\\",
    \\"error_rate_target\\": \\"< 1%\\"
  },
  \\"deployment_time\\": \\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\"
}" > monitoring/performance-baseline.json
                            
                            echo "‚úÖ Performance monitoring configured"
                        '''
                    }
                }
                
                stage('Health Check Setup') {
                    steps {
                        echo 'üè• Setting up health monitoring...'
                        sh '''
                            echo "Configuring health checks..."
                            
                            # Create health check script
                            cat > monitoring/health-check.sh << 'EOF'
#!/bin/bash
echo "Health check for ${APP_NAME} v${BUILD_VERSION}"
echo "Timestamp: $(date)"
curl -f http://localhost:3000/ -o /dev/null -s -w "HTTP Status: %{http_code}, Response Time: %{time_total}s\\n" || echo "Health check failed"
echo "Health check completed"
EOF
                            
                            chmod +x monitoring/health-check.sh
                            
                            echo "‚úÖ Health monitoring configured"
                        '''
                    }
                }
                
                stage('Alert Configuration') {
                    steps {
                        echo 'üö® Setting up monitoring alerts...'
                        sh '''
                            echo "Configuring monitoring alerts..."
                            
                            # Create alerting configuration
                            echo "{
  \\"alerts\\": {
    \\"response_time\\": {
      \\"threshold\\": \\"500ms\\",
      \\"action\\": \\"email\\",
      \\"recipients\\": [\\"${NOTIFICATION_EMAIL}\\"]
    },
    \\"error_rate\\": {
      \\"threshold\\": \\"5%\\",
      \\"action\\": \\"email\\",
      \\"recipients\\": [\\"${NOTIFICATION_EMAIL}\\"]
    },
    \\"uptime\\": {
      \\"threshold\\": \\"99%\\",
      \\"action\\": \\"email\\",
      \\"recipients\\": [\\"${NOTIFICATION_EMAIL}\\"]
    }
  }
}" > monitoring/alert-config.json
                            
                            echo "‚úÖ Alert configuration created"
                        '''
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'monitoring/**/*', allowEmptyArchive: true
                }
                success {
                    echo '‚úÖ Monitoring setup completed successfully'
                }
            }
        }
    }
    
    // ==================== POST ACTIONS ====================
    post {
        always {
            echo 'üßπ Pipeline cleanup...'
            
            // Archive all reports and logs
            archiveArtifacts artifacts: '**/*.log,**/*-report.*,**/*.json', allowEmptyArchive: true
            
            // Clean workspace
            cleanWs()
        }
        
        success {
            echo '‚úÖ Pipeline completed successfully!'
            
            // Send success notification
            emailext (
                subject: "‚úÖ Pipeline Success - ${APP_NAME} #${BUILD_NUMBER}",
                body: """
                    <h3>Pipeline Completed Successfully</h3>
                    <p><strong>Project:</strong> ${APP_NAME}</p>
                    <p><strong>Version:</strong> ${BUILD_VERSION}</p>
                    <p><strong>Branch:</strong> ${GIT_BRANCH_NAME}</p>
                    <p><strong>Commit:</strong> ${GIT_COMMIT_SHORT}</p>
                    <p><strong>Build URL:</strong> ${BUILD_URL}</p>
                    
                    <h4>Pipeline Stages:</h4>
                    <ul>
                        <li>‚úÖ Checkout</li>
                        <li>‚úÖ Build</li>
                        <li>‚úÖ Test</li>
                        <li>‚úÖ Code Quality</li>
                        <li>‚úÖ Security</li>
                        <li>‚úÖ Deploy</li>
                        <li>‚úÖ Release</li>
                        <li>‚úÖ Monitoring</li>
                    </ul>
                """,
                to: env.NOTIFICATION_EMAIL
            )
        }
        
        failure {
            echo '‚ùå Pipeline failed!'
            
            // Send failure notification
            emailext (
                subject: "‚ùå Pipeline Failed - ${APP_NAME} #${BUILD_NUMBER}",
                body: """
                    <h3>Pipeline Failed</h3>
                    <p><strong>Project:</strong> ${APP_NAME}</p>
                    <p><strong>Build:</strong> ${BUILD_URL}</p>
                    <p><strong>Branch:</strong> ${GIT_BRANCH_NAME}</p>
                    <p><strong>Commit:</strong> ${GIT_COMMIT_SHORT}</p>
                    
                    <p>Please check the build logs for more details.</p>
                """,
                to: env.NOTIFICATION_EMAIL
            )
        }
        
        unstable {
            echo '‚ö†Ô∏è Pipeline completed with warnings'
        }
    }
}